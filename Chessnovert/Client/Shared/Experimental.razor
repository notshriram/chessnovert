@using Chessnovert.Shared
@using Chessnovert.Shared.Chess
@using Chessnovert.Shared.Chess.Enums
@using Microsoft.AspNetCore.SignalR.Client

<div class="board">
    @for (int i = 0; i < 8; i++)
    {
        int Row = PlayerColor == Color.Black ? i : 7 - i;
        <div class="rank">
            @for (int j = 0; j < 8; j++)
            {
                int Col = PlayerColor == Color.Black ? j : 7 - j;
                Piece? piece = board[Row, Col];
                Coordinate position = new Coordinate { Row = Row, Col = Col };

                bool isValid = false;
                if (activePiece != null)
                {
                    isValid = TryMove(activePiece.Position, position);
                }
                <div @onclick="()=>MoveToPosition(position)" class="cell @(isValid?"valid":"")">
                    @if (piece != null)
                    {
                        <div @onclick="()=>SelectPiece(piece)"
                 class="piece @piece.Name @piece.Color.ToString() @(piece == activePiece? "active" : "")">
                        </div>
                    }
                </div>
            }
        </div>
    }
</div>

<button class="btn btn-dark" @onclick="()=>PrintMovesCount(searchDepth, true)">Move Generation Test</button>

@code {

    public int searchDepth = 1;
    public Chessnovert.Shared.Game Game { get; set; } = new();

    [Parameter]
    public Color? PlayerColor { get; set; }

    Piece[,] board = new Piece[8, 8];
    Piece activePiece = null!;
    Color currentTurn;
    int validMoves = 0;
    int HalfMoveClock = 0;
    int FullMoveCounter = 1;
    // Castling Rights KQkq

    public string movestring = "";
    public int movenumber = 0;

    public Stack<Move> MoveStack = new();
    public Stack<bool[]> CastlingRightsStack = new();

    async Task PrintMovesCount(int depth, bool singlePass)
    {
        for (int i = singlePass ? depth : 1; i <= depth; i++)
        {
            int count = await MoveGenerationTest(i);
            Console.WriteLine($"\nNodes searched: {count}");
        }
        searchDepth++;
    }

    //protected override async Task OnInitializedAsync()
    //{
    //    for (int i = 1; i <= 5; i++)
    //    {
    //        var numOfMoves = await MoveGenerationTest(i);
    //        Console.WriteLine($"Depth {i} Ply: No. Of Moves {numOfMoves}");
    //    }
    //}

    private Piece? PieceFromChar(char c, Coordinate position)
    {
        switch (c)
        {
            case 'P':
                return new Pawn(Color.White, position);
            case 'N':
                return new Knight(Color.White, position);
            case 'B':
                return new Bishop(Color.White, position);
            case 'R':
                return new Rook(Color.White, position);
            case 'Q':
                return new Queen(Color.White, position);
            case 'K':
                return new King(Color.White, position);
            case 'p':
                return new Pawn(Color.Black, position);
            case 'n':
                return new Knight(Color.Black, position);
            case 'b':
                return new Bishop(Color.Black, position);
            case 'r':
                return new Rook(Color.Black, position);
            case 'q':
                return new Queen(Color.Black, position);
            case 'k':
                return new King(Color.Black, position);
            default:
                return null;
        }
    }

    public void PositionFromFEN(string FEN)
    {
        string[] fen = FEN.Split(' ');
        foreach (var i in fen)
        {
            Console.WriteLine(i);
        }
        string[] rows = fen[0].Split('/');
        for (int i = 0; i < 8; i++)
        {
            int col = 0;
            for (int j = 0; j < rows[i].Length; j++)
            {
                if (rows[i][j] >= '1' && rows[i][j] <= '8')
                {
                    col += rows[i][j] - '0';
                }
                else
                {
                    int r = 7 - i;
                    int c = 7 - col;
                    board[r,c] = PieceFromChar(rows[i][j], new Coordinate { Row = r, Col = c })!;
                    col++;
                }
            }
        }
        currentTurn = fen[1] == "w" ? Color.White : Color.Black;

        var castlingRights = new bool[4] { false, false, false, false };
        if (fen[2].Contains('K'))
            castlingRights[0] = true;
        if (fen[2].Contains('Q'))
            castlingRights[1] = true;
        if (fen[2].Contains('k'))
            castlingRights[2] = true;
        if (fen[2].Contains('q'))
            castlingRights[3] = true;
        
        CastlingRightsStack.Push(castlingRights);

        // TODO: en passant

        if(fen.Length > 4 && int.TryParse(fen[4], out int halfMoveClock))
        {
            HalfMoveClock = halfMoveClock;
        }
        if (fen.Length > 5 && int.TryParse(fen[5], out int fullMoveCounter))
        {
            FullMoveCounter = fullMoveCounter;
        }

        validMoves = CountValidMoves(currentTurn);
    }

    protected override void OnInitialized()
    {
        PositionFromFEN("r3k2r/p1ppqpb1/bn2pnp1/3PN3/1p2P3/2N2Q1p/PPPBBPPP/R3K2R w KQkq - ");

        base.OnInitialized();

        // Play all the moves that have occured upto this point
        List<Move> moves = Game.Moves;
        if (moves.Count != 0)
        {
            foreach (var move in moves)
            {
                OnMoveEvent(move.Source, move.Destination, Game.TimeControl);
            }
        }
        else
        {
            Console.WriteLine("Empty Move List");
        }

        for (int i = 0; i < 8; i++)
        {
            for (int j = 0; j < 8; j++)
            {
                if (board[i, j] != null)
                    Console.Write(board[i, j].Value);
            }
            Console.WriteLine();
        }

    }


    protected void MoveToPosition(Coordinate position)
    {
        Console.WriteLine(position);
        if (activePiece != null)
        {

            if (TryMove(activePiece.Position, position))
            {
                //Console.WriteLine("legal");
                var source = activePiece.Position;
                var destination = position;

                var sourcePiece = board[source.Row, source.Col];
                var destinationPiece = board[destination.Row, destination.Col];
                if (sourcePiece != null)
                {
                    if (sourcePiece.IsLegal(destination, board))
                    {
                        //Console.WriteLine("Pseudo Legal Check Passed");
                        //Check for En Passant
                        if (Game != null)
                        {
                            if (Game.Moves.Count != 0)
                                if (sourcePiece.Value == 'P' && Math.Abs(destination.Col - source.Col) == 1)
                                {
                                    if (Game.Moves.Last().Destination.Row == source.Row)
                                    {
                                        var last = Game.Moves.Last();
                                        Piece? lastMovedPiece = board[last.Destination.Row, last.Destination.Col];
                                        if (lastMovedPiece == null)
                                        {
                                            throw new InvalidOperationException();
                                        }

                                        if (lastMovedPiece.Value == 'P')
                                        {
                                            if (TryMove(source, destination))
                                            {
                                                board[last.Destination.Row, last.Destination.Col] = null!;
                                            }
                                        }
                                    }
                                }
                        }
                    }
                    Move move = new Move(activePiece.Position, position, activePiece.Color, board[destination.Row, destination.Col]);
                    MakeMove(move);
                    Game.Moves.Add(move);
                    activePiece = null!;
                    Console.WriteLine($"It's {currentTurn}'s turn");
                    validMoves = CountValidMoves(currentTurn);
                    if (validMoves == 0)
                    {
                        Console.WriteLine("Checkmate");
                    }
                }
            }
            else if (position == activePiece.Position)
            {
                Console.WriteLine("Selected " + activePiece.Color + activePiece.Name);
            }
            else
            {
                activePiece = null!;
                //Console.WriteLine("illegal");
            }
        }
    }
    protected void OnMoveEvent(Coordinate source, Coordinate destination, TimeSpan remainingTime)
    {
        Console.WriteLine("Moved from " + source + " to " + destination);
        var sourcePiece = board[source.Row, source.Col];
        if (sourcePiece != null)
        {
            activePiece = sourcePiece;

            if (activePiece.IsLegal(destination, board))
            {
                if (activePiece.Value == 'K'
                && (destination.Row == activePiece.Position.Row)
                && (Math.Abs(destination.Col - activePiece.Position.Col) == 2))
                {
                    if (CanCastle(activePiece, destination))
                    {
                        var position = destination;
                        int direction = activePiece.Position.Col > position.Col ? -1 : 1;
                        Piece? rook = board[activePiece.Position.Row, position.Col + direction];
                        Coordinate rookDestination = new Coordinate(position.Row, position.Col - direction);

                        board[rook.Position.Row, rook.Position.Col] = null!;
                        rook.Position = rookDestination;
                        board[rookDestination.Row, rookDestination.Col] = rook;
                    }
                    else return;

                }
                //Console.WriteLine("legal");
                board[activePiece.Position.Row, activePiece.Position.Col] = null!;
                activePiece.Position = destination;
                board[destination.Row, destination.Col] = activePiece;
                activePiece = null!;
            }
        }
        currentTurn = currentTurn == Color.White ? Color.Black : Color.White;
        Console.WriteLine($"It's {currentTurn}'s turn");
        validMoves = CountValidMoves(currentTurn);
        if (validMoves == 0)
        {
            Console.WriteLine("Game Over");
        }
        StateHasChanged();
    }

    protected void SelectPiece(Piece piece)
    {
        if (currentTurn != piece.Color)
        {
            return;
        }
        activePiece = piece;
    }

    protected bool IsKingInCheck(Color color)
    {
        Piece? king = null;
        for (int i = 0; i < 8; i++)
        {
            for (int j = 0; j < 8; j++)
            {
                if (board[i, j] != null && board[i, j].Value == 'K')
                {
                    if (board[i, j].Color == color)
                    {
                        king = board[i, j];
                    }
                }
            }
        }
        // WTF
        if (king == null)
        {
            throw new NullReferenceException($"No {color} King Found");
        }

        for (int i = 0; i < 8; i++)
        {
            for (int j = 0; j < 8; j++)
            {
                Piece? currentPiece = board[i, j];
                if (currentPiece != null)
                {
                    if (currentPiece.IsLegal(king.Position, board))
                    {
                        //Console.WriteLine($"{currentPiece.Color} {currentPiece.Name} can capture {color} King");
                        return true;
                    }
                }
            }
        }
        return false;
    }

    private bool IsCastling(Move move)
    {
        if (move.IsCastling) return true;
        Piece? sourcePiece = board[move.Source.Row, move.Source.Col];
        if (sourcePiece == null) return false;
        return (sourcePiece.Value == 'K' && (move.Destination.Row == move.Source.Row) && (Math.Abs(move.Destination.Col - move.Source.Col) == 2));
    }

    protected bool TryMove(Coordinate source, Coordinate destination)
    {
        Piece? sourcePiece = board[source.Row, source.Col];
        Piece? destinationPiece = board[destination.Row, destination.Col];
        bool isIllegal = true;
        if (sourcePiece != null)
        {
            if (sourcePiece.IsLegal(destination, board))
            {
                //Console.WriteLine($"{sourcePiece.Name} is Pseudo Legal from {sourcePiece.Position} to {destination}");
                //Check for En Passant
                if (MoveStack.Count != 0 && destinationPiece == null)
                    if (sourcePiece.Value == 'P' && Math.Abs(destination.Col - source.Col) == 1)
                    {
                        Move last = MoveStack.Peek();
                        if (last.Destination.Row == source.Row)
                        {
                            Piece? lastMovedPiece = board[last.Destination.Row, last.Destination.Col];
                            if (lastMovedPiece == null)
                            {
                                throw new InvalidOperationException();
                            }

                            if (lastMovedPiece.Value == 'P' && (lastMovedPiece.Position.Col == destination.Col) && (Math.Abs(last.Source.Row - last.Destination.Row) == 2))
                            {
                                board[last.Destination.Row, last.Destination.Col] = null!;

                                // make move
                                board[source.Row, source.Col] = null!;
                                sourcePiece.Position = destination;
                                board[destination.Row, destination.Col] = sourcePiece;

                                if (!IsKingInCheck(sourcePiece.Color))
                                {
                                    isIllegal = false;
                                }
                                // unmake move
                                board[destination.Row, destination.Col] = destinationPiece!;
                                sourcePiece.Position = source;
                                board[source.Row, source.Col] = sourcePiece;

                                board[last.Destination.Row, last.Destination.Col] = lastMovedPiece;
                                return !isIllegal;

                            }
                            else
                            {
                                return false;
                            }
                        }
                        else
                        {
                            return false;
                        }
                    }

                Move move = new Move(source, destination, currentTurn, destinationPiece);

                if (IsCastling(move))
                    return CanCastle(sourcePiece, destination);

                MakeMove(move);

                if (!IsKingInCheck(sourcePiece.Color))
                {
                    isIllegal = false;
                }

                UnmakeMove(move);
            }
        }
        return !isIllegal;
    }

    protected bool CanCastle(Piece king, Coordinate destination)
    {

        if (king.Value != 'K')
        {
            return false;
        }
        if (king.Position.Row != destination.Row)
        {
            return false;
        }
        if (IsKingInCheck(king.Color))
        {
            return false;
        }
        // check castling rights
        if (king.Color == Color.White)
        {

            if (destination.Col == 1)
            {
                if (!CastlingRightsStack.Peek()[0])
                {
                    return false;
                }
            }
            else if (destination.Col == 5)
            {
                if (!CastlingRightsStack.Peek()[1])
                {
                    return false;
                }
            }
        }
        else
        {
            if (destination.Col == 1)
            {
                if (!CastlingRightsStack.Peek()[2])
                {
                    return false;
                }
            }
            else if (destination.Col == 5)
            {
                if (!CastlingRightsStack.Peek()[3])
                {
                    return false;
                }
            }

        }

        int direction = king.Position.Col > destination.Col ? -1 : 1;

        for (int i = king.Position.Col + direction; i != destination.Col; i += direction)
            if (!TryMove(king.Position, new Coordinate(destination.Row, i)))
                return false;

        bool isIllegal = true;

        Move move = new Move(king.Position, destination, king.Color, null);
        MakeMove(move);

        if (!IsKingInCheck(king.Color))
        {
            isIllegal = false;
        }

        UnmakeMove(move);
        return !isIllegal;
    }

    public int CountValidMoves(Color color)
    {
        int count = 0;
        for (int i = 0; i < 8; i++)
            for (int j = 0; j < 8; j++)
            {
                Coordinate source = new Coordinate(i, j);
                if (board[i, j] != null && board[i, j].Color == color)
                {
                    for (int r = 0; r < 8; r++)
                        for (int c = 0; c < 8; c++)
                        {
                            Coordinate destination = new Coordinate(r, c);
                            if (TryMove(source, destination)) count++;
                        }
                }
            }
        return count;
    }

    public List<Move> GenerateMoveList()
    {
        List<Move> MoveList = new();
        for (int i = 0; i < 8; i++)
            for (int j = 0; j < 8; j++)
            {
                Coordinate source = new Coordinate(i, j);
                if (board[i, j] != null && board[i, j].Color == currentTurn)
                {
                    for (int r = 0; r < 8; r++)
                        for (int c = 0; c < 8; c++)
                        {
                            Coordinate destination = new Coordinate(r, c);
                            if (TryMove(source, destination))
                            {
                                MoveList.Add(new Move(source, destination, board[i, j].Color, board[r, c]));
                            }
                        }
                }
            }
        return MoveList;
    }

    public async Task<int> MoveGenerationTest(int depth)
    {
        if (depth == 0)
        {
            return 1;
        }
        List<Move> moves = GenerateMoveList();
        int count = 0;
        foreach (var move in moves)
        {
            MakeMove(move);

            //movenumber++;
            //movestring = $"{source} {destination}";

            //StateHasChanged();
            //await Task.Delay(150);

            int localCount = await MoveGenerationTest(depth - 1);
            count += localCount;

            // function perft(k)
            if(depth==searchDepth)
                Console.WriteLine($"{(move.Source.ToString() + move.Destination.ToString()).ToLower()}: {localCount}");

            // unmake move
            UnmakeMove(move);

            //StateHasChanged();
            //await Task.Delay(150);

        }
        return count;
    }

    public void MakeMove(Move move)
    {
        Piece? sourcePiece = board[move.Source.Row, move.Source.Col];
        Piece? destinationPiece = board[move.Destination.Row, move.Destination.Col];

        //Console.WriteLine($"Making move {sourcePiece.Name}{move.Source}{move.Destination}");

        // castling
        if (IsCastling(move))
        {
            move.IsCastling = true;
            int direction = sourcePiece.Position.Col > move.Destination.Col ? -1 : 1;

            // cannot be dest col + direction for queenside rook
            Piece? rook = board[sourcePiece.Position.Row, move.Destination.Col + direction];
            if (direction == 1)
            {
                rook = board[sourcePiece.Position.Row, 7];
            }

            Coordinate rookDestination = new Coordinate(sourcePiece.Position.Row, move.Destination.Col - direction);

            board[rook.Position.Row, rook.Position.Col] = null!;
            rook.Position = rookDestination;
            board[rookDestination.Row, rookDestination.Col] = rook;
            //Console.WriteLine($"Rook Castle destination {rookDestination}");
        }

        //make move
        board[move.Source.Row, move.Source.Col] = null!;
        sourcePiece.Position = move.Destination;
        board[move.Destination.Row, move.Destination.Col] = sourcePiece;

        MoveStack.Push(move);
        //set castling rights
        bool[] castlingRights = CastlingRightsStack.Peek().ToArray();
        if (sourcePiece.Value == 'K')
        {
            if (sourcePiece.Color == Color.White)
            {
                castlingRights[0] = false;
                castlingRights[1] = false;
            }
            else
            {
                castlingRights[2] = false;
                castlingRights[3] = false;
            }
        }
        else if (sourcePiece.Value == 'R')
        {
            if (sourcePiece.Color == Color.White)
            {
                if (sourcePiece.Position.Col == 0)
                    castlingRights[0] = false;
                else if (sourcePiece.Position.Col == 7)
                    castlingRights[1] = false;
            }
            else
            {
                if (sourcePiece.Position.Col == 0)
                    castlingRights[2] = false;
                else if (sourcePiece.Position.Col == 7)
                    castlingRights[3] = false;
            }
        }
        CastlingRightsStack.Push(castlingRights);
        currentTurn = currentTurn == Color.White ? Color.Black : Color.White;

    }

    public void UnmakeMove(Move move)
    {
        // unmake move
        Piece? sourcePiece = board[move.Destination.Row, move.Destination.Col];

        if(sourcePiece == null)
        {
            Console.WriteLine($"Error while unmoving {move.Source}{move.Destination} with isCastling {move.IsCastling} and captured = {move.Displaced!=null}");
            Console.WriteLine($"Null sourcepiece on {move.Destination}");
            throw new Exception();
        }



        //Console.WriteLine($"Unmaking move {sourcePiece.Name}{move.Source}{move.Destination}");

        // castling
        if (IsCastling(move))
        {
            int direction = move.Source.Col > move.Destination.Col ? -1 : 1;
            Piece? rook = board[sourcePiece.Position.Row, move.Destination.Col - direction];

            Coordinate rookDestination = new Coordinate(move.Source.Row, move.Destination.Col + direction);
            if (direction == 1)
            {
                rookDestination = new Coordinate(move.Source.Row, 7);
            }
            board[rook.Position.Row, rook.Position.Col] = null!;
            rook.Position = rookDestination;
            board[rookDestination.Row, rookDestination.Col] = rook;
            //Console.WriteLine($"Rook Uncastle destination {rookDestination}");
        }

        board[move.Destination.Row, move.Destination.Col] = move.Displaced!;
        sourcePiece.Position = move.Source;
        board[move.Source.Row, move.Source.Col] = sourcePiece;

        MoveStack.Pop();
        CastlingRightsStack.Pop();
        currentTurn = currentTurn == Color.White ? Color.Black : Color.White;
    }
}
